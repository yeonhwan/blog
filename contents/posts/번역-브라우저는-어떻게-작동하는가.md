---
title: 번역) 브라우저는 어떻게 작동하는가?
date: 2023-11-08T00:00:00.000Z
tags:
  - 브라우저
  - 번역
excerpt: 브라우저는 어떻게 작동하는가?
publish: true
slug: 번역-브라우저는-어떻게-작동하는가
---

원글)
_[How Browsers Work: Everything Developers Need To Know](https://medium.com/@jankammerath/how-browsers-work-everything-developers-need-to-know-f58c3560c53d)_ by Jan Kammerath

![](https://velog.velcdn.com/images/yeonhwan619/post/324a82e5-edbd-443d-ab31-7f8e02d62a68/image.png)

# 서문

나는 테크리더이자 매니저 그리고 다수의 개발 팀들을 관리하는 CTO로서, 지난 20여년 동안 수십명의 소프트웨어 개발자들을 인터뷰했다.

나는 적합성을 판가름하는 인터뷰 질문 리스트를 특정하게 정해놓고 사용하지는 않지만, 프로그래밍과 컴퓨팅 그리고 네트워킹이라는 분야에 대한 지식을 판단할 수 있는 좋아하는 몇 가지의 질문들을 가지고 있다.

내가 계속해서 개발자들에게 물어보기 좋아하는 질문들 중 하나는 이것이다.

> _"당신이 브라우저 아이콘을 클릭하는 그 순간부터 당신이 스크린에서 홈페이지를 보기까지의 순간에 무슨 일이 일어나는지 설명해주겠는가?"_

나는 이 질문을 백번도 넘게 물어보았던 것 같다. 단순히 개발자들과의 직무 면접에서 뿐만 아니라 소프트웨어 비즈니스에서 기술직군 비기술직군의 직원들을 상대로 하는 다양한 프로그램에서도 말이다.

이 질문은 한 사람이 인터넷에 대해서 어느정도로 이해하고 있는 가를 판단할 수 있는 질문일 뿐만 아니라 사람들에게 실제로 인터넷이 어떻게 동작하는지 훈련시킬 수 있는 훌륭한 시작점이다.

많은 개발자들과 함께했던 나의 경험들 속에서 나는 많은 개발자들이 사실은 인터넷과 브라우저가 정확히 어떻게 동작하는지 알지 못하고 IP 프로토콜이 무엇을 위한 것이며 또한 어떻게 이러한 서비스들이 서로 간의 연결되어있는지를 알지 못한다는 것을 발견했다.

우리는 매일 매일 배워 나가고 있으며 지식들에 대한 각자마다의 성취도가 다르기 때문에 모든 것을 다 알지 못해도 괜찮다.

우리는 이제 부터 브라우저 아이콘을 클릭해 렌더링된 웹 페이지를 보기까지의 과정을 경험할 것이다. 당신이 이러한 모든 세부사항들을 전부 알고 있는지 한 번 살펴보고 그렇지 않다면 이 과정은 훌륭한 학습 경험이 될 것이다.

---

<br/>

## 당신이 "인터넷을 열면" 어떠한 일이 일어나는 가

일반적인 비기술 직군의 사람들은 그들의 인터넷 브라우저를 소위 _"인터넷"_ 이라고 생각한다. 그들은 인터넷과, IP 프로토콜을 통해 동작하는 과정과, 월드 와이드 웹, HTTP 프로토콜을 통해 동작하는 과정들이 모두 다르다고 생각하지 않는다. 그들은 브라우저 어플리케이션을 실행시키는 것을 _"온라인에 접속한다", "인터넷을 연다"_ 또는 _"웹을 실행시킨다"_ 라고 이야기한다. 사회적으로는 이러한 문장들이 용인되고 받아들여질 수 있긴 하지만 기술적으로 이러한 이야기는 거의 전부 옳지 않다.

초보 개발자들은 보통, 그들의 직업을 고려했을 때, 실제로 어떠한 일들이 발생하는 가에 대해서 보다 더 잘 알고 있다. 내가 인터뷰 중에 이에 대해서 더 깊게 질문하면, 그들의 지식이 여전히 중요한 세부 사항들을 놓치고 있다는 사실들이 드러나기는 하지만 말이다. 많은 개발자들은 HTTP 와 같은 응용계층의 프로토콜이 어떻게 작동하는지에 대해서 어느정도 익숙하다. 하지만 종종 IP, TCP 그리고 DNS에 대해서 깊은 지식을 가지고 있지는 않아 보인다. 현대의 다양한 환경에서 배포되어있는 어플리케이션들에 대해서(클라우드, 온프레미스, 모바일, 임베디드), 이러한 지식들은 굉장히 중요하다. 특히 어플리케이션이나 시스템의 네트워킹 활동과 관련되어 있는 에러들을 해결해야 할 때 말이다.

![](https://velog.velcdn.com/images/yeonhwan619/post/7169a4e7-0f1b-4cb7-96fb-792201d5c838/image.png)

모든 것이 보다 단순하고 좀더 느렸던 1995년에 나는 처음으로 월드 와이드 웹을 접하긴 했지만, 이 과정 자체는 지금까지 거의 동일하게 유지되고 있다. 오늘날과 그 당시의 가장 큰 차이점이라고 하면, 현재는 네트워킹을 사용하지 않는 어플리케이션이 거의 남아있지 않다는 사실이다. 90년대 이야기를 하자면, 그때 당시에는 윈도우 95 데스크탑 어플리케이션을 네트워킹과 관련된 어떠한 것도 한 번 신경쓰지 않고 만들어낼 수 있었다. 인터넷, IP, ICMP, TCP 그리고 UDP 말이다.

웹사이트를 컴퓨터에서 로딩하고 렌더링하는 과정은 거의 모든 컴퓨팅 플랫폼에서 동일하게 동작한다. Windows 에서도 그렇고, Linux, macOS, iOS, Android나 삼성TV에서도 말이다. 그들은 다양한 물리적 환경에서 동일한 작업을 수행한다. 현재의 가장 물리적으로 흔한 미디어는 _IEEE 802.3 (이더넷, 종종 LAN이나 로컬 네트워크라고), IEEE 802.11 (와이파이나 무선 LAN) 그리고 3GPP 15 (모바일 네트워크나 4G, 5G) 이후 버전에 정의되어 있다._ 간단 명료하게 하기 위해서, 우리는 이 과정을 사람들이 가장 비슷하게 사용하고 있는 Windows, Linux, macOS, iOS 그리고 Android에 집중하도록 하겠다.

### #1 브라우저 어플리케이션을 로딩시키기

당신의 기기의 운영 체제에는 _"인터넷 브라우저"_ 라고 불리우는 어플리케이션이 설치되어있다. 오늘날의 대부분의 운영체제들은 브라우저 어플리케이션이 탑재되어 나온다. Windows의 경우에는 _"Microsoft Edge"_, macOS와 iOS의 경우에는 _"Safari"_, Android에는 _"Google Chrome"_, 대부분의 Linux의 배포버전에는 _"Mozilla Firefox"_ 가 설치되어 있다.\n

![](https://velog.velcdn.com/images/yeonhwan619/post/66e70b41-ca67-4501-bf03-627a753be318/image.png)_Windows 11은 Microsoft Edge 가 기본 설정으로 따라온다._

<br/>

당신은 브라우저 어플리케이션을 실행프로그램*(데스크탑이나 홈스크린에 존재하는 바로가기 아이콘)_을 클릭하는 것으로 _"실행 "_ 시킨다. 실행시킨다는 것의 정확한 뜻은 당신이 운영체제에게 응용프로그램의 바이너리 파일을 디스크나 저장소등의 그것이 존재하는 위치로부터 기기의 메인메모리_(RAM)*로 로딩하라는 명령을 내린 것을 의미한다. 그리고 CPU에서 바이너리에 존재하는 프로그램을 실행시킨 것이 해당한다. 모든 브라우저들이 대부분 시스템 언어인 C, C++, Rust, Go로 작성되어있기에, 브라우저의 실행파일 또는 바이너리는 실제 기계어를 포함하고 있다.\n

보다 장황하지 않고 간단하고 짧게 설명하기 위해서, 어떻게 운영 체제가 이러한 응용프로그램을 다루고 실행시키는지에 대해서는 설명하지 않을 것이다. 우리는 운영체제에 대한 부분에 대해서 추상적인 단계로 남겨두고, 운영체제가 드라이버를 통해서 NIC*(네트워크 인터페이스 카드)*와 어떻게 소통하고 기저에서 네트워킹에 어떻게 접속하는지에 대한 사실을 살펴볼 것이다.\n

### #2 브라우저가 네트워크 라이브러리를 초기 설정하기

그 당시에 내가 Windows 95에서 Netscape Navigator를 사용했던 많은 날들에서, 나는 브라우저가 실행된 직후 곧 바로 다이얼-업 프롬프트롤 볼 수 있었다. _(과거 인터넷에 접속하기 위해서는 전화를 통해서 인터넷 연결을 할 수 있었고 이를 컴퓨터에서 연결시키는 과정을 보여주는 화면을 말한다.)_ 이렇게 작동했던 이유는 브라우저가 시스템 라이브러리가 네트워킹을 위해서 연결을 초기설정하기 위해서였다. 이러한 라이브러리들은 브라우저 응용프로그램으로부터 모든 네트워킹 기능들을 추상화했고 이를 통해서 근본적으로 네트워크 스택들에 대해 처리하지 않도록 하기 위해서였다. Windows 95 에서는 이것이 윈도우즈 소켓 API를 제공했던 winsock.dll _(Windows Socket Library)_ 였다. 소켓 라이브러리는 저단계의 프로토콜인 IP*(Internet Protocol)_와 같은 것들을 신경쓰지 않고도 TCP 연결들을 다룰 수 있도록 해주는 TCP
_(Transport Control Protocol)_ 소켓을 제공해 주었다. 나의 Windows 95 컴퓨터가 다이얼-업 모뎀을 사용했기 때문에, 운영 체제는 나_(사용자)*로 부터 다이얼-업 연결을 통해 네트워킹 기능을 브라우저 응용프로그램에 제공할 것인지 확인받았다.

![](https://velog.velcdn.com/images/yeonhwan619/post/3dd2333f-2aa9-40c7-9f47-d3a402bd7a45/image.png)

#### IP와 물리적 연결에 대해 작업하기

하지만 만약 당신이 인터넷 프로토콜과 네트워크 어댑터들과 상호작용 하고 싶다면, 대부분의 프로그래밍 언어들은 시스템 라이브러리를 통해 네트워크 인터페이스의 정보에 접근 할 수 있도록 해주는 추상 라이브러리들을 가지고 있다. 밑의 코드는 Go로 작성된, 모든 네트워크 인터페이스 들과 그들의 연결 상태, 가능한 IP 주소들을 보여주는 코드이다.

```go
package main

import (
 "fmt"
 "net"
)

func main() {
 ifaces, err := net.Interfaces()
 if err != nil {
  panic(err)
 }
 for _, iface := range ifaces {
  fmt.Printf("%v:\n", iface.Name)
  addrs, err := iface.Addrs()
  if err != nil {
   panic(err)
  }
  for _, addr := range addrs {
   fmt.Printf("  %v\n", addr)
  }
  fmt.Printf("  connected: %v\n", iface.Flags&net.FlagUp != 0)
 }
}
```

밑의 어플리케이션의 결과는 나의 루프백 어댑터 _"lo0"_, 맥북 와이파이 어댑터 _"en0"_ 그리고 USB 이더넷 어댑터 _"en7"_ 을 보여준다. 이들 모두는 연결되어 있으며 IPv4 와 IPv6 주소를 가지고 있다. 현대의 많은 사람들과 같이 내가 개인용 네트워크를 가지고 있음을 생각할때, 나의 어댑터들은 모두 개인용 IP 주소들을 가지고 있으며 그들의 IP 패킷들이 내 지하에 있는 주 라우터를 통해 라우팅하고 있다는 것을 알 수 있다.

```bash
jan@MacBook-Pro-von-Jan % go run network.go
lo0:
  127.0.0.1/8
  ::1/128
  fe80::1/64
  connected: true
en0:
  fe80::4d6:ca0d:249d:fda7/64
  192.168.1.143/24
  connected: true
en7:
  fe80::8bd:7605:50b:d8da/64
  192.168.1.70/24
  connected: true
```

다음의 _"traceroute"_ 커맨드는 IP 패킷들이 Google.de의 IP 주소로 향하는 경로들을 보여준다. Traceroute 는 ICMP*(Internet Control Message Protocol: 네트워크 장치에서 네트워크 통신 문제를 진단하는 데 사용하는 네트워크 계층 프로토콜, 진단에 사용할 수 있는 메세지들을 정의해놓았다)*을 사용한다. 또한 유명한 진단 도구인 _"ping" (해당 IP 를 가진 장비에 접속 가능한지 확인하는 프로그램 echo request 를 던지고, 이로 부터 받은 echo reply 를 확인한다. 정상적으로 echo reply 를 수신하는 경우 수신까지 걸릴 시간을 계산하여 해당 장비까지 회선 속도를 가늠할 수 있다.)_을 사용하는데, 이는 _ICMP Echo Request_ 메세지를 보낸다. 인터넷 프로토콜_(IP 또는 IPv4, IPv6)_ 또한 ICMP와 같이 인터넷 계층에서 가장 널리 사용되는 프로토콜이다.

```bash
traceroute to 142.250.185.163 (142.250.185.163), 64 hops max, 52 byte packets
 1  192.168.1.1 (192.168.1.1)  1.616 ms  0.597 ms  0.322 ms
 2  p3e9bf1b6.dip0.t-ipconnect.de (62.155.241.182)  4.747 ms * *
 3  ip-081-210-128-120.um21.pools.vodafone-ip.de (81.210.128.120)  10.827 ms
    f-ed11-i.f.de.net.dtag.de (62.154.17.150)  13.730 ms
    f-ed11-i.f.de.net.dtag.de (217.5.109.30)  10.114 ms
 4  80.150.170.70 (80.150.170.70)  12.342 ms  12.040 ms  12.030 ms
 5  84.116.190.94 (84.116.190.94)  16.651 ms  18.213 ms  16.965 ms
 6  108.170.252.1 (108.170.252.1)  45.377 ms
    74.125.32.52 (74.125.32.52)  21.895 ms  21.209 ms
 7  * 108.170.251.144 (108.170.251.144)  9.793 ms *
 8  142.250.226.148 (142.250.226.148)  21.620 ms
    fra16s51-in-f3.1e100.net (142.250.185.163)  12.968 ms  12.779 ms

```

브라우저는 IP 나 ICMP와는 어떠한 관계도 없다. 운영체제가 이러한 부분의 모든 것들을 현대적인 운영 시스템에서 관리하고 처리한다. 90년대 초, 브라우저들은 종종 그들만의 IP나 TCP 스택들을 포함해야했는데 이것들이 가끔 운영 체제내에 포함되어 있지 않았기 때문이다. 모든 IP 설정이 완료되고 운영체제가 브라우저를 위한 네트워킹을 초기설정하고 나면, 브라우저는 이제 나서서 작업에 뛰어들 수 있다 : _"웹을 탐색하는 것 말이다."_
